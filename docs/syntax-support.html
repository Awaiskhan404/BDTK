
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Syntax support in Cider &#8212; Cider 1.0 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Cider User Guide" href="user-guide.html" />
    <link rel="prev" title="Cider Developer Guide" href="develop-guide.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="user-guide.html" title="Cider User Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="develop-guide.html" title="Cider Developer Guide"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Cider 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="syntax-support-in-cider">
<h1>Syntax support in Cider<a class="headerlink" href="#syntax-support-in-cider" title="Permalink to this headline">¶</a></h1>
<div class="section" id="having-syntax-support">
<h2>1 Having syntax support<a class="headerlink" href="#having-syntax-support" title="Permalink to this headline">¶</a></h2>
<p>Generally, there are two cases in having.
One is non-agg condition(See Case1 below) which will be regarded as filter operator and pushed down before group by partial agg.</p>
<p>Case1:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">col_a</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sum_a</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">col_a</span> <span class="k">HAVING</span> <span class="n">col_a</span> <span class="o">&gt;</span> <span class="mi">2</span>
</pre></div>
</div>
<p>The other one is agg condition(See Case2 below) which should be handled after group by final agg.</p>
<p>Case2:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">col_a</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sum_a</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">col_a</span> <span class="k">HAVING</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
</pre></div>
</div>
<p>For Case1 in Cider, we will get substrait plan in which having clause is transfered to filter operator already.
When it comes to Case3 that contains multiple conditions, we will receive a substrait plan with multiple
conditions. Then Cider will merge all those conditions and push them down before group by partial agg.</p>
<p>Case3:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">col_a</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sum_a</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">WHERE</span> <span class="n">col_a</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">col_a</span> <span class="k">HAVING</span> <span class="n">col_a</span> <span class="o">&gt;</span> <span class="mi">2</span>
</pre></div>
</div>
<p>For Case2 in Cider, we expect to get two plans. One is table scan and partial agg, the other is final agg, filter and project.
So when it comes to Case4, two different conditions from where and having won’t appear in a same substrait plan and be merged
into single EU.</p>
<p>Case4:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">col_a</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sum_a</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">WHERE</span> <span class="n">col_a</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">col_a</span> <span class="k">HAVING</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
</pre></div>
</div>
<p>In addition to those above, if we get an unexpected substrait plan like putting having agg condition together with partial
agg plan, we will get wrong result batch without throwing exception.</p>
</div>
<div class="section" id="in-syntax-support">
<h2>2 In syntax support<a class="headerlink" href="#in-syntax-support" title="Permalink to this headline">¶</a></h2>
<p>The IN clause allows multi values definition in WHERE conditions. For example:
.. code-block:: sql</p>
<blockquote>
<div>SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,…);</div></blockquote>
<p>Under this scenario, user translates IN expression to a substrait <a class="reference external" href="https://github.com/substrait-io/substrait/blob/b8fb06a52397463bfe9cffc2c89fe71eba56b2ca/proto/substrait/algebra.proto#L387">ScalaFunction</a> with <a class="reference external" href="https://github.com/substrait-io/substrait/blob/b8fb06a52397463bfe9cffc2c89fe71eba56b2ca/proto/substrait/algebra.proto#L501">List</a> as its second arg. Then Cider translates it into Analyzer::InValues for further codegen and computation.</p>
<p>IN can also be used together with a subquery:
.. code-block:: sql</p>
<blockquote>
<div><p>SELECT eno
FROM employee
WHERE dno IN</p>
<blockquote>
<div>(SELECT dno
FROM dept
WHERE floor = 3);</div></blockquote>
</div></blockquote>
<p>In this case, plan parser in frontend framework will parse it either “IN (value1, value2, …)” or a JoinNode
when ‘eno’ col is known as a primary key or an unique index, like following:
.. code-block:: sql</p>
<blockquote>
<div>SELECT eno
FROM employee join dept
WHERE employee.dno = dept.dno and dept.floor = 3</div></blockquote>
<p>Thus this IN clause is handled through join op in Cider.</p>
</div>
<div class="section" id="avg-support-in-cider">
<h2>3 AVG support in Cider<a class="headerlink" href="#avg-support-in-cider" title="Permalink to this headline">¶</a></h2>
<p>Similar as other aggregation functions, ‘AVG’ has 2 phases(Partial/Final) in distributing data analytic engines. But computation is different in different phase. In AVG partial, computation is split into sum() and count() on target column/expression and in AVG final, sum() is done on previous summation and count value, then do a divide between these 2 values.</p>
<p>Since Cider is positioned as a compute library under such a distributed engine at task level, it doesn’t support AVG syntax directly in its internal.</p>
<p>It may have some conflictions when frontend framework offloads AVG function to Cider, mainly caused by different signature of referred functions, such as output type, etc. Take Velox for example, it specifies <strong>sum(int)</strong> with output type <strong>double</strong> in avg aggregation, while it violates rules in cider which uses output type <strong>bigint</strong>. This will cause codegen check failure. So for this case, we made a workaround by following Cider rules in internal and convert result to <strong>double</strong> when retriving result into CiderBatch, thus can keep consistent schema with following op in velox plan, such as avg final computation.</p>
<p>Similar special handle will be needed when output type of agg functions from frontend framework violates with cider internal. In cider, the returned data types defined as following:</p>
<table border="1" class="colwidths-given docutils align-left">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Aggregate Function</th>
<th class="head">Output Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SUM</td>
<td>If argument is integer, output type will be BIGINT. Otherwise same as argument type.</td>
</tr>
<tr class="row-odd"><td>MIN</td>
<td>Same as argument type.</td>
</tr>
<tr class="row-even"><td>MAX</td>
<td>Same as argument type.</td>
</tr>
<tr class="row-odd"><td>COUNT</td>
<td>If g_bigint_count is true(default false), output type is BIGINT. Otherwise uses INT.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="string-function-support-in-cider">
<h2>4 String Function support in Cider<a class="headerlink" href="#string-function-support-in-cider" title="Permalink to this headline">¶</a></h2>
<p>Currently, Cider do not distinguish empty string and null string.</p>
<div class="section" id="like-function">
<h3>1) Like function<a class="headerlink" href="#like-function" title="Permalink to this headline">¶</a></h3>
<ol class="loweralpha simple">
<li>Acceptable wildcards: %, _, []</li>
<li>Unacceptable wildcards: <a href="#id1"><span class="problematic" id="id2">*</span></a>, [^], [!]</li>
<li>Escape clause is not supported yet.</li>
</ol>
</div>
</div>
<div class="section" id="conditional-expressions-in-cider">
<h2>5 Conditional Expressions in Cider<a class="headerlink" href="#conditional-expressions-in-cider" title="Permalink to this headline">¶</a></h2>
<div class="section" id="coalesce">
<h3>1) COALESCE<a class="headerlink" href="#coalesce" title="Permalink to this headline">¶</a></h3>
<p>The COALESCE expression is a syntactic shortcut for the CASE expression</p>
<p>The code COALESCE(expression1,…n) is executed in Cider as the following CASE expression:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CASE</span>
<span class="k">WHEN</span> <span class="p">(</span><span class="n">expression1</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span> <span class="k">THEN</span> <span class="n">expression1</span>
<span class="k">WHEN</span> <span class="p">(</span><span class="n">expression2</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span> <span class="k">THEN</span> <span class="n">expression2</span>
<span class="p">...</span>
<span class="k">ELSE</span> <span class="n">expressionN</span>
<span class="k">END</span>
</pre></div>
</div>
<div class="section" id="example">
<h4>Example:<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">COALESCE</span><span class="p">(</span><span class="n">col_1</span><span class="p">,</span> <span class="n">col_2</span><span class="p">,</span> <span class="mi">777</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test</span>
</pre></div>
</div>
<p>is equal to</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">col_1</span> <span class="k">is</span> <span class="k">not</span> <span class="k">null</span> <span class="k">THEN</span> <span class="n">col_1</span> <span class="k">WHEN</span> <span class="n">col_2</span> <span class="k">is</span> <span class="k">not</span> <span class="k">null</span> <span class="k">THEN</span> <span class="n">col_2</span> <span class="k">ELSE</span> <span class="mi">777</span> <span class="k">END</span> <span class="k">from</span> <span class="n">test</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="if">
<h3>2) IF<a class="headerlink" href="#if" title="Permalink to this headline">¶</a></h3>
<p>The IF function is actually a language construct that is executed in Cider as the following CASE expression:</p>
<div class="section" id="if-functions">
<h4>IF Functions:<a class="headerlink" href="#if-functions" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li></li>
</ol>
<p>Evaluates and returns true_value if condition is true, otherwise null is returned and true_value is not evaluated.</p>
<p>is equal to</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">condition</span> <span class="k">THEN</span> <span class="n">true_value</span> <span class="k">END</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li></li>
</ol>
<p>Evaluates and returns true_value if condition is true, otherwise evaluates and returns false_value.</p>
<p>is equal to</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">condition</span> <span class="k">THEN</span> <span class="n">true_value</span> <span class="k">ELSE</span> <span class="n">false_value</span> <span class="k">END</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="group-by-related-function">
<h2>6 GROUP BY related function<a class="headerlink" href="#group-by-related-function" title="Permalink to this headline">¶</a></h2>
<p>This part will explain extended usage of GROUP BY including GROUPING SETS() , CUBE() , ROLLUP() , GROUP BY ALL/DISTINCT, and together with those combined cases.</p>
<p>Let’s define a simple test table the schema of which is</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tbl</span><span class="p">(</span><span class="n">col_a</span> <span class="nb">BIGINT</span><span class="p">,</span> <span class="n">col_b</span> <span class="nb">BIGINT</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="grouping-sets">
<h3>1) GROUPING SETS<a class="headerlink" href="#grouping-sets" title="Permalink to this headline">¶</a></h3>
<p>Grouping sets allow users to specify multiple lists of columns to group on. The columns not part of a given sublist of grouping columns are set to <strong>NULL</strong>.</p>
<p>Example:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">GROUPING</span> <span class="k">SETS</span><span class="p">(</span>
        <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">),</span>
        <span class="p">(</span><span class="n">col_a</span><span class="p">),</span>
        <span class="p">(</span><span class="n">col_b</span><span class="p">),</span>
        <span class="p">())</span>
</pre></div>
</div>
<p>Plan:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- Output[_col0]
- Project[projectLocality = LOCAL]
- Aggregate(FINAL)[col_a$gid, col_b$gid, groupid][$hashvalue]
- Aggregate(PARTIAL)[col_a$gid, col_b$gid, groupid][$hashvalue_8]
- Project[projectLocality = LOCAL]
- GroupId[[col_a, col_b], [col_a], [col_b], []]
- TableScan
</pre></div>
</div>
<p>is <strong>logically equivalent</strong> to:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">tbl</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">tbl</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">col_a</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">tbl</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">col_b</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">tbl</span>
</pre></div>
</div>
<p>However, the only difference of them is using UNION ALL will trigger tableScan four times while only once for GROUPING SETS.</p>
<p>This is important not only for performance, data quality will also be a significant problem when the source table varies from time to time.</p>
</div>
<div class="section" id="group-by-rollup">
<h3>2) GROUP BY ROLLUP<a class="headerlink" href="#group-by-rollup" title="Permalink to this headline">¶</a></h3>
<p>The ROLLUP operator generates all possible subtotals for a given set of columns.</p>
<div class="section" id="id3">
<h4>Example:<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">ROLLUP</span> <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">)</span>
</pre></div>
</div>
<p>Plan:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- Output[_col0]
- Project[projectLocality = LOCAL]
- Aggregate(FINAL)[col_a$gid, col_b$gid, groupid][$hashvalue]
- Aggregate(PARTIAL)[col_a$gid, col_b$gid, groupid][$hashvalue_8]
- Project[projectLocality = LOCAL]
- GroupId[[], [col_a], [col_a, col_b]]
- TableScan
</pre></div>
</div>
<p>is <strong>equivalent</strong> to:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">GROUPING</span> <span class="k">SETS</span><span class="p">(</span>
        <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">),</span>
        <span class="p">(</span><span class="n">col_a</span><span class="p">),</span>
        <span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="group-by-cube">
<h3>3) GROUP BY CUBE<a class="headerlink" href="#group-by-cube" title="Permalink to this headline">¶</a></h3>
<p>The CUBE operator generates all possible grouping sets (i.e. a power set) for a given set of columns.</p>
<div class="section" id="id4">
<h4>Example:<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">CUBE</span> <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">)</span>
</pre></div>
</div>
<p>Plan:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- Output[_col0]
- Project[projectLocality = LOCAL]
- Aggregate(FINAL)[col_a$gid, col_b$gid, groupid][$hashvalue]
- Aggregate(PARTIAL)[col_a$gid, col_b$gid, groupid][$hashvalue_8]
- Project[projectLocality = LOCAL]
- GroupId[[], [col_a], [col_b], [col_a, col_b]]
- TableScan
</pre></div>
</div>
<p>is <strong>equivalent</strong> to:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">GROUPING</span> <span class="k">SETS</span><span class="p">(</span>
        <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">),</span>
        <span class="p">(</span><span class="n">col_a</span><span class="p">),</span>
        <span class="p">(</span><span class="n">col_b</span><span class="p">),</span>
        <span class="p">());</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="group-by-all-distinct">
<h3>4) GROUP BY ALL/DISTINCT<a class="headerlink" href="#group-by-all-distinct" title="Permalink to this headline">¶</a></h3>
<p>We don’t need to handle ALL/DISTINCT in Cider, since it will be transfered to GROUPING SETS when generating Presto plans.
The ALL and DISTINCT quantifiers determine whether duplicate grouping sets each produce distinct output rows.
This is particularly useful when multiple complex grouping sets are combined in the same query.</p>
<div class="section" id="example1">
<h4>Example1:<a class="headerlink" href="#example1" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">ALL</span> <span class="k">ROLLUP</span> <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">),</span> <span class="k">CUBE</span> <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">)</span>
</pre></div>
</div>
<p>Plan:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- Output[_col0]
- Project[projectLocality = LOCAL]
- Aggregate(FINAL)[col_a$gid, col_b$gid, groupid][$hashvalue]
- Aggregate(PARTIAL)[col_a$gid, col_b$gid, groupid][$hashvalue_8]
- Project[projectLocality = LOCAL]
- GroupId[[], [col_a], [col_a, col_b], [col_a], [col_a], [col_a, col_b], [col_b], [col_b, col_a], [col_b, col_a], [col_a, col_b], [col_a, col_b], [col_a, col_b]]
- TableScan
</pre></div>
</div>
<p>is <strong>equivalent</strong> to:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span>
<span class="k">GROUPING</span> <span class="k">SETS</span> <span class="p">((</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">),</span> <span class="p">(</span><span class="n">col_a</span><span class="p">),</span> <span class="p">()),</span>
<span class="k">GROUPING</span> <span class="k">SETS</span><span class="p">((</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">),</span> <span class="p">(</span><span class="n">col_a</span><span class="p">),</span> <span class="p">(</span><span class="n">col_b</span><span class="p">),</span> <span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="example2">
<h4>Example2:<a class="headerlink" href="#example2" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">DISTINCT</span> <span class="k">ROLLUP</span> <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">),</span> <span class="k">CUBE</span> <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">)</span>
</pre></div>
</div>
<p>Plan:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- Output[_col0]
- Project[projectLocality = LOCAL]
- Aggregate(FINAL)[col_a$gid, col_b$gid, groupid][$hashvalue]
- Aggregate(PARTIAL)[col_a$gid, col_b$gid, groupid][$hashvalue_8]
- Project[projectLocality = LOCAL]
- GroupId[[], [col_a], [col_a, col_b], [col_b]]
- TableScan
</pre></div>
</div>
<p>is <strong>equivalent</strong> to:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span>
<span class="k">GROUPING</span> <span class="k">SETS</span> <span class="p">((</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">),</span> <span class="p">(</span><span class="n">col_a</span><span class="p">),</span> <span class="p">(</span><span class="n">col_b</span><span class="p">),</span> <span class="p">());</span>
</pre></div>
</div>
<p>Using ALL will leave all duplicate grouping sets while DISTINCT will dedup them.</p>
</div>
</div>
<div class="section" id="grouping-operation">
<h3>5) GROUPING() operation<a class="headerlink" href="#grouping-operation" title="Permalink to this headline">¶</a></h3>
<p>We can find the usage of SELECT GROUPING(col_a, col_b …) FROM table GROUP BY ROLLUP (col_a, col_b …)  in TPC-DS Query27.
The grouping operation returns a bit set converted to decimal, indicating which columns are present in a grouping.
It must be used in conjunction with GROUPING SETS, ROLLUP, CUBE or GROUP BY and its arguments must match exactly the columns referenced in the corresponding GROUPING SETS, ROLLUP, CUBE or GROUP BY clause.</p>
<div class="section" id="id5">
<h4>Example:<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">col_a</span><span class="p">),</span> <span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">,</span> <span class="k">GROUPING</span><span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">col_b</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">tbl</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">GROUPING</span> <span class="k">SETS</span><span class="p">((</span><span class="n">col_a</span><span class="p">),</span> <span class="p">(</span><span class="n">col_b</span><span class="p">));</span>
</pre></div>
</div>
<p>Result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_col0</span> <span class="o">|</span> <span class="n">col_a</span> <span class="o">|</span> <span class="n">col_b</span> <span class="o">|</span> <span class="n">_col3</span>
<span class="o">-------+-------+-------+-------</span>
<span class="mi">2</span> <span class="o">|</span> <span class="n">NULL</span>  <span class="o">|</span>     <span class="mi">3</span> <span class="o">|</span>     <span class="mi">2</span>
<span class="mi">4</span> <span class="o">|</span>     <span class="mi">2</span> <span class="o">|</span> <span class="n">NULL</span>  <span class="o">|</span>     <span class="mi">1</span>
<span class="mi">3</span> <span class="o">|</span>     <span class="mi">3</span> <span class="o">|</span> <span class="n">NULL</span>  <span class="o">|</span>     <span class="mi">1</span>
<span class="mi">1</span> <span class="o">|</span> <span class="n">NULL</span>  <span class="o">|</span>     <span class="mi">1</span> <span class="o">|</span>     <span class="mi">2</span>
<span class="mi">1</span> <span class="o">|</span>     <span class="mi">1</span> <span class="o">|</span> <span class="n">NULL</span>  <span class="o">|</span>     <span class="mi">1</span>
<span class="mi">2</span> <span class="o">|</span> <span class="n">NULL</span>  <span class="o">|</span>     <span class="mi">2</span> <span class="o">|</span>     <span class="mi">2</span>
<span class="mi">3</span> <span class="o">|</span> <span class="n">NULL</span>  <span class="o">|</span>     <span class="mi">4</span> <span class="o">|</span>     <span class="mi">2</span>
<span class="p">(</span><span class="mi">7</span> <span class="n">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>The example shows when GROUP BY col_a, the bit set should be 01, so the value of _col3 is 1.
When GROUP BY col_b, the bit set should be 10, thus the value of _col3 is 2.</p>
<p>The GROUPING(col_a, col_b) results in _col3 and it represents a bit set converted to BIGINT.
Each column in GROUPING  operation will take one bit and it will be set to 0 if the corresponding column is included in the grouping and to 1 otherwise.
=======
&gt;&gt;&gt;&gt;&gt;&gt;&gt; address comments</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Syntax support in Cider</a><ul>
<li><a class="reference internal" href="#having-syntax-support">1 Having syntax support</a></li>
<li><a class="reference internal" href="#in-syntax-support">2 In syntax support</a></li>
<li><a class="reference internal" href="#avg-support-in-cider">3 AVG support in Cider</a></li>
<li><a class="reference internal" href="#string-function-support-in-cider">4 String Function support in Cider</a><ul>
<li><a class="reference internal" href="#like-function">1) Like function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conditional-expressions-in-cider">5 Conditional Expressions in Cider</a><ul>
<li><a class="reference internal" href="#coalesce">1) COALESCE</a><ul>
<li><a class="reference internal" href="#example">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#if">2) IF</a><ul>
<li><a class="reference internal" href="#if-functions">IF Functions:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#group-by-related-function">6 GROUP BY related function</a><ul>
<li><a class="reference internal" href="#grouping-sets">1) GROUPING SETS</a></li>
<li><a class="reference internal" href="#group-by-rollup">2) GROUP BY ROLLUP</a><ul>
<li><a class="reference internal" href="#id3">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#group-by-cube">3) GROUP BY CUBE</a><ul>
<li><a class="reference internal" href="#id4">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#group-by-all-distinct">4) GROUP BY ALL/DISTINCT</a><ul>
<li><a class="reference internal" href="#example1">Example1:</a></li>
<li><a class="reference internal" href="#example2">Example2:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-operation">5) GROUPING() operation</a><ul>
<li><a class="reference internal" href="#id5">Example:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="develop-guide.html"
                        title="previous chapter">Cider Developer Guide</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="user-guide.html"
                        title="next chapter">Cider User Guide</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/syntax-support.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="user-guide.html" title="Cider User Guide"
             >next</a> |</li>
        <li class="right" >
          <a href="develop-guide.html" title="Cider Developer Guide"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Cider 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Intel.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>